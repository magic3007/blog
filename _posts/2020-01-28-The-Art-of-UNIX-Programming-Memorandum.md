---
layout: article 
title: The Art of UNIX Programming
---



[TOC]


列举几个例子加以理解.

# 设计原则

## Modularity 模块性

> 如何能够真正实现 "不会直接调用其他模块的实现码" ?

实现模块化与解耦合是实际上不是一件那么容易的事情. 在面向对象编程中, 就目前的经验来看, 我会把API分成两大类:

- 一类是提供给他人使用, 不会对自身的状态产生影响. 这类比较简单, 直接提供接口即可.
- 另外一类是上希望对方在特定的地方调用, 或者是会对自身状态的产业影响的. 这些需要自己把API<u>注册</u>到对方的函数表上, 对方不知道这个函数是什么, 只需要知道在特定的事件调用的即可, 表现在汇编语言上即为间接跳转, 另一方面也体现着 把知识叠入数据的*表示原则*.

> 最佳模块大小是多少?

400-800物理行, 过多过少均不宜.

> 常见的违反紧凑性和正交性的例子有哪些?

- API入口点(如函数参数)超过了七个(*The Magical Number Seven, Plus or Minus Two: Some Limits on Our Capacity for Processing Information*)

- 目标是从某一(源)格式到另一个(目标)格式进行数据读取和解析, 却想当然得认为是从磁盘读取(为什么不能是标准输入, 网络套接字或者其他来源的数据流呢?)

> 如何提高设计的紧凑性和正交性?

- ~~入禅门: "教外别传, 不立文字", 依赖将导致痛苦~~
- 围绕"解决一个定义明确的问题"的强核心<u>算法</u>组织设计, 避免人为的假设(抽象, 抽象, 还是抽象!)

> 如何看待UNIX的薄胶合层原则与OO(面向对象)的过度封装?

- UNIX的模块化强调薄胶合层原则, 即硬件和程序顶层对象之间的抽象层越少越好
- 需要警惕OO显示出来的某种使程序员过度封装的倾向.

## Textuality 文本化



# Reference

[The Art of Unix Programming](http://www.catb.org/~esr/writings/taoup/html/)

